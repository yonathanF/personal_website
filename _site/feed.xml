<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://yonathanfisseha.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://yonathanfisseha.com/" rel="alternate" type="text/html" /><updated>2020-02-18T00:44:06-05:00</updated><id>https://yonathanfisseha.com/feed.xml</id><title type="html">Yonathan Fisseha</title><subtitle>University of Virginia</subtitle><author><name>Yonathan Fisseha</name></author><entry><title type="html">A Study in Software Correctness</title><link href="https://yonathanfisseha.com/software-correctness/2020/02/18/intro.html" rel="alternate" type="text/html" title="A Study in Software Correctness" /><published>2020-02-18T00:00:00-05:00</published><updated>2020-02-18T00:00:00-05:00</updated><id>https://yonathanfisseha.com/software-correctness/2020/02/18/intro</id><content type="html" xml:base="https://yonathanfisseha.com/software-correctness/2020/02/18/intro.html">&lt;p&gt;Software engineering is a relatively young field compared to other engineering fields, such as civil engineering. As a result, many of our techniques for software construction are still in the early stages of their evolution. For example, consider that software testing became common only in the late/mid 2000s, and the sentiment that testing is not important is still common. As we generate more data across various industries, the need for secure, reliable, and efficient software also increases. This has become apparent in the number of data breaches both large and small business face, the unreliable applications that plague the app stores, and the painfully inefficient code that is scattered all over the web. Sparse test cases that are written just for the sake of hitting an arbitrary coverage criteria are clearly insufficient.&lt;/p&gt;

&lt;p&gt;My undergraduate study and research has been broadly concerned with addressing some of the problems mentioned above. Particularly, I have been interested in improving algorithmic efficiency via data compression techniques. These series of blogs (see: Software-Correctness category) mark somewhat of a diversion from this path while remaining under the same overarching theme. This will be my independent study of software reliability as I prepare for graduate school to study the topic full-time.&lt;/p&gt;

&lt;h1 id=&quot;plan&quot;&gt;Plan&lt;/h1&gt;
&lt;p&gt;My overarching goal here is to understand how we can construct software with more formal guarantees than simple test cases. The approach I will use it to first study formal methods and verification. Here, I have chosen to take a programming-focused approach since my background is in computer science. I am working through &lt;em&gt;Gentle Introduction to Dependent Types with Idris&lt;/em&gt; by Boro Sitnikovski. I came across dependent types while I was browsing through a local library and found &lt;em&gt;Type-Driven Development with Idris&lt;/em&gt; by Edwin Brady. &lt;a href=&quot;https://www.idris-lang.org/&quot;&gt;Idris&lt;/a&gt; is a programming language with dependent types and enables programmers to write proofs of correctness with their code. I will work through some sections of &lt;em&gt;Type-Driven Development&lt;/em&gt; once I finish Sitnikovski’s book.&lt;/p&gt;

&lt;p&gt;I plan on reading and writing on other related works and concepts, e.g. church encoding and lambda calculus in general, Hindley-Damas-Milner type system, typed lambda calculus and why it’s not Turing complete, and Brouwer–Heyting–Kolmogorov interpretation. These are topics I have come across but were not covered in depth in the reading I was doing (I expect this list will continue to grow over the course of my study). Eventually, I plan to work through &lt;em&gt;Purely Functional Data Structures&lt;/em&gt; by Chris Okasaki and (maybe?) &lt;em&gt;Homotopy Type Theory&lt;/em&gt; from the Institute for Advanced Study.&lt;/p&gt;

&lt;h2 id=&quot;why-publish-it&quot;&gt;Why publish it?&lt;/h2&gt;

&lt;p&gt;I decided to write these up and publish them as blogs for two reasons:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;This topic is not very accessible to people outside of the research area. If you are interested in the overall topic or specific parts, this can be a good starting point.&lt;/li&gt;
  &lt;li&gt;I usually take digital notes while reading and writing with the intention of publishing might improve my writing/understanding.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;schedule&quot;&gt;Schedule&lt;/h2&gt;

&lt;p&gt;My goal is to publish 1 article per month at minimum (hopefully more if my schedule allows it).&lt;/p&gt;</content><author><name>Yonathan Fisseha</name></author><summary type="html">Software engineering is a relatively young field compared to other engineering fields, such as civil engineering. As a result, many of our techniques for software construction are still in the early stages of their evolution. For example, consider that software testing became common only in the late/mid 2000s, and the sentiment that testing is not important is still common. As we generate more data across various industries, the need for secure, reliable, and efficient software also increases. This has become apparent in the number of data breaches both large and small business face, the unreliable applications that plague the app stores, and the painfully inefficient code that is scattered all over the web. Sparse test cases that are written just for the sake of hitting an arbitrary coverage criteria are clearly insufficient.</summary></entry></feed>